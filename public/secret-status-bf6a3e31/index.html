<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="robots" content="noindex, nofollow"/>
<title>Minecraft Bedrock – Status</title>
<meta name="color-scheme" content="dark light"/>
<style>
:root{
  --bg:#0b0d11; --panel:#0f1320; --line:#1b2231;
  --fg:#e6e7eb; --muted:#9aa0a6;
  --g:#19c37d; --r:#ef4444; --o:#f59e0b; --u:#95a3b6;
  --radius:12px;
  --cols: 288;
}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
.wrap{max-width:1100px;margin:28px auto;padding:0 16px}

/* Header */
header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:16px}
h1{margin:0;font-size:22px}
.pill{display:inline-flex;align-items:center;gap:8px;background:linear-gradient(180deg,var(--panel),#0b0f1a);
  border:1px solid var(--line);padding:8px 12px;border-radius:999px;font-size:13px}
.dot{width:10px;height:10px;border-radius:50%}
.dot.g{background:var(--g)} .dot.r{background:var(--r)} .dot.u{background:var(--u)}

/* Toolbar */
.top-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:8px}
.seg{display:inline-flex;border:1px solid var(--line);border-radius:10px;overflow:hidden}
.seg input{display:none}
.seg label{padding:6px 10px;font-size:12px;color:var(--muted);cursor:pointer}
.seg input:checked + label{background:var(--line);color:var(--fg)}
.toggle{display:inline-flex;align-items:center;gap:8px;font-size:12px;color:var(--muted)}
.toggle input{accent-color:#60a5fa}

/* Card */
.card{background:linear-gradient(180deg,var(--panel),#0c111c);border:1px solid var(--line);
  border-radius:var(--radius);padding:16px}
.row-head{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
.svc{display:flex;flex-direction:column;gap:4px;min-width:240px}
.svc-name{font-weight:700}
.svc-host{font-size:12px;color:var(--muted)}
.badges{display:flex;gap:8px;flex-wrap:wrap}
.badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;
  border:1px solid var(--line);font-size:12px;background:linear-gradient(180deg,#0c1423,#0a0f1a)}
.badge-warn{border-color:#f59e0b; box-shadow:0 0 0 1px #f59e0b66 inset}
.kpi{display:flex;gap:16px;flex-wrap:wrap;color:var(--muted);font-size:12px;margin-top:8px}
.kpi strong{color:var(--fg);font-weight:600}

/* Bars as Grid */
.bars-wrap{margin-top:12px;position:relative}
.bars{
  position:relative;
  display:grid;
  grid-template-columns: repeat(var(--cols), minmax(3px, 1fr));
  gap:6px;
  align-items:end;
  min-height:90px;
  padding:10px;
  border-radius:12px;
  background:linear-gradient(180deg,#0a0e19,#0a0d14);
  overflow:hidden;
  overscroll-behavior: contain;
  touch-action: pan-y; /* vertikal scrollen bleibt */
}
.bars.mode-24h{min-height:70px; gap:4px}
.bar{
  height:60px; border-radius:8px; background:#2a3242; box-shadow:inset 0 0 0 1px rgba(0,0,0,.25)
}
.bar.g{background:var(--g)} .bar.r{background:var(--r)} .bar.o{background:var(--o)} .bar.u{background:var(--u)}
.bar.focus{outline:2px solid #ffffff50; outline-offset:1px;}

/* Hoverline nur Desktop */
.hoverline{
  position:absolute; top:10px; bottom:10px; width:2px;
  background:#ffffff40; pointer-events:none; display:none;
}

/* Footer Text */
.footline{display:flex;justify-content:space-between;color:var(--muted);font-size:12px;margin:6px 4px 0}

/* Legend */
.legend{display:flex;gap:14px;color:var(--muted);font-size:12px;flex-wrap:wrap;margin-top:8px}
.lg{display:inline-flex;align-items:center;gap:6px}
.sq{width:10px;height:10px;border-radius:2px}
.sq.g{background:var(--g)} .sq.r{background:var(--r)} .sq.o{background:var(--o)} .sq.u{background:var(--u)}

.disclaimer{margin-top:8px;font-size:12px;color:var(--muted)}
.incidents{margin-top:10px}
.incidents h3{margin:8px 0 6px;font-size:13px;color:var(--muted);font-weight:600}
.incidents ul{margin:0;padding-left:16px;font-size:12px;color:var(--muted)}
.incidents li{margin:4px 0}
.stale{margin-top:8px;font-size:12px;color:#fbbf24}

/* Tip */
.tip{position:fixed;pointer-events:none;z-index:70;transform:translate(-50%,-120%);
  background:#0b0f18;border:1px solid var(--line);padding:8px 10px;border-radius:8px;
  font-size:12px;box-shadow:0 10px 30px rgba(0,0,0,.45);display:none;min-width:220px;max-width:90vw}
.t-line{display:flex;justify-content:space-between;gap:10px}

/* Heatmap */
.heat{margin-top:18px}
.heat h3{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:600}
.hm{display:grid;grid-template-columns:repeat(13,1fr);gap:4px}
.hm .cell{height:12px;border-radius:3px;background:#2a3242}
.hm .g{background:var(--g)} .hm .o{background:var(--o)} .hm .r{background:var(--r)} .hm .u{background:var(--u)}
.hm .label{grid-column:span 13;font-size:11px;color:var(--muted);margin-top:6px}

/* Sparkline */
#lat-spark { display:flex; gap:2px; align-items:flex-end; height:28px; margin-top:8px }
#lat-spark .s { width:3px; background:#374151; border-radius:2px; }
#lat-spark .s.ok { background: var(--g); }
#lat-spark .s.warn { background: var(--o); }
#lat-spark .s.bad { background: var(--r); }

/* Mobile */
@media (max-width:520px){
  h1{font-size:18px}
  .svc-host,.badge{font-size:11px}
  .seg label{padding:6px 8px}
  .bars{gap:6px}
  .bar{min-width:10px;height:56px}
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Minecraft Bedrock – Status</h1>
    <div class="pill" id="live-pill" aria-live="polite">
      <span class="dot u" id="live-dot"></span>
      <span id="live-txt">Lade Live-Status …</span>
    </div>
  </header>

  <div class="top-row" role="toolbar">
    <div class="seg" id="range">
      <input type="radio" name="r" id="r24" value="24h" checked><label for="r24">24 h</label>
      <input type="radio" name="r" id="r7" value="7d"><label for="r7">7 d</label>
      <input type="radio" name="r" id="r30" value="30d"><label for="r30">30 d</label>
    </div>
    <label class="toggle"><input type="checkbox" id="auto" checked/> Live-Refresh (60 s)</label>
  </div>

  <section class="card">
    <div class="row-head">
      <div class="svc">
        <div class="svc-name" id="svc-name">Minecraft Bedrock</div>
        <div class="svc-host" id="svc-host">–</div>
      </div>
      <div class="badges">
        <div class="badge"><span>Uptime</span><strong id="uptime">–</strong></div>
        <div class="badge"><span>Downtime</span><strong id="downtime">–</strong></div>
        <div class="badge" id="lat-badge"><span>Latency</span><strong id="lat-val">–</strong></div>
      </div>
    </div>

    <div class="kpi">
      <div><strong id="kpi-online">–</strong> online</div>
      <div><strong id="kpi-offline">–</strong> offline</div>
      <div><strong id="kpi-unknown">–</strong> unknown</div>
      <div><strong id="kpi-points">–</strong> Punkte</div>
    </div>

    <div class="bars-wrap">
      <div id="bars" class="bars mode-24h" role="group" aria-label="Zeitachse"></div>
      <div id="hoverline" class="hoverline"></div>
      <div class="footline"><span id="foot-left">24 hours</span><span id="foot-right">Today</span></div>
      <div id="lat-spark" aria-label="Latency Sparkline"></div>
    </div>

    <div class="legend">
      <span class="lg"><span class="sq g"></span> online</span>
      <span class="lg"><span class="sq r"></span> offline</span>
      <span class="lg"><span class="sq o"></span> eingeschränkt</span>
      <span class="lg"><span class="sq u"></span> unbekannt</span>
      <span class="lg">• <span id="legend-interval">1 Balken = 1 Probe (variable Minuten)</span> • <span id="meta-src">Quelle: History</span></span>
    </div>

    <p class="disclaimer">Diese Daten sind Schätzungen bzw. Pings an den Server und können nicht zu 100&nbsp;% stimmen.</p>

    <div class="incidents" id="inc"></div>
    <div class="stale" id="stale" hidden>Hinweis: History ist älter als 30 Min. Live zeigt den aktuellen Zustand.</div>

    <div class="heat">
      <h3>Kalender-Heatmap (letzte 90 Tage)</h3>
      <div class="hm" id="heatmap"></div>
    </div>
  </section>
</div>

<!-- Tooltip -->
<div class="tip" id="tip">
  <div class="t-line"><span id="tip-status">–</span><span id="tip-ts">–</span></div>
  <div class="t-line"><span id="tip-src">–</span><span id="tip-range">–</span></div>
</div>

<script>
/* === Endpoints === */
const API_HISTORY='/api/history';
const API_LIVE='/api/bedrock';
const API_INCIDENTS='/incidents.json';
const API_LATENCY='/latency.json';

const SLOT_MIN=5, DAY_MS=86400000, STALE_MIN=30, INCIDENT_MIN=15;

/* Latency thresholds */
const P95_WARN = 200;
const P95_BAD  = 250;
const DEGRADE_WINDOW_MIN = 10;

/* DOM */
const $=id=>document.getElementById(id);
const barsEl=$('bars'), hoverLine=$('hoverline'), rangeCtl=$('range'), autoCtl=$('auto');
const liveDot=$('live-dot'), liveTxt=$('live-txt'), svcName=$('svc-name'), svcHost=$('svc-host');
const uptimeEl=$('uptime'), dtimeEl=$('downtime'), kOnline=$('kpi-online'), kOffline=$('kpi-offline'), kUnknown=$('kpi-unknown'), kPoints=$('kpi-points');
const metaSrc=$('meta-src'), incWrap=$('inc'), staleEl=$('stale'), heatEl=$('heatmap'), legendInterval=$('legend-interval');
const TIP=$('tip'), TIP_TS=$('tip-ts'), TIP_ST=$('tip-status'), TIP_SRC=$('tip-src'), TIP_RANGE=$('tip-range');
const latBadge=$('lat-badge'), latVal=$('lat-val'), latSpark=$('lat-spark');

const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints>0;

/* Utils */
const clamp=(x,min,max)=>Math.max(min,Math.min(max,x));
const fmtPct=v=> (isNaN(v)?'–':(v*100).toFixed(2)+'%');
const fmtDur=m=> m<60?`${m} min`:`${Math.floor(m/60)} h ${m%60} min`;
const localTime=iso=> new Date(iso).toLocaleString();
const localDate=iso=> new Date(iso).toLocaleDateString(undefined,{year:'numeric',month:'short',day:'numeric'});
const statusClass = ok => ok===true?'g': ok===false?'r':'u';
const statusText  = ok => ok===true?'online': ok===false?'offline':'unbekannt';

async function fetchJSON(u, opts={}){ const r=await fetch(u,{cache:'no-store',...opts}); if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }
function clear(el){while(el.firstChild)el.removeChild(el.firstChild)}
function setLive(ok,ts){liveDot.className='dot '+statusClass(ok); liveTxt.textContent=`${statusText(ok)} • ${ts?localTime(ts):'–'}`;}

/* Cache */
const cacheKey=(range)=>`hist:${range}`;
async function loadHistory(range){
  const qs=`?range=${encodeURIComponent(range)}`;
  try{ const d=await fetchJSON(API_HISTORY+qs); localStorage.setItem(cacheKey(range),JSON.stringify({t:Date.now(),d})); return d; }
  catch(e){
    try{ const d=await fetchJSON(API_HISTORY); localStorage.setItem(cacheKey(range),JSON.stringify({t:Date.now(),d})); return d; }
    catch(err){ const raw=localStorage.getItem(cacheKey(range)); if(raw) return JSON.parse(raw).d; throw err; }
  }
}

/* Build intervals from raw points */
function toIntervals(points, nowIso){
  const arr=[...points].sort((a,b)=>new Date(a.ts)-new Date(b.ts));
  const out=[];
  for(let i=0;i<arr.length;i++){
    const from=new Date(arr[i].ts);
    const to=new Date(i<arr.length-1?arr[i+1].ts:(nowIso||new Date().toISOString()));
    const mins=Math.max(1, Math.round((to-from)/60000)); // echte Dauer, min 1
    out.push({from:arr[i].ts,to:to.toISOString(),ok:arr[i].ok,mins});
  }
  return out;
}

/* KPIs, incidents */
function computeIncidents(intervals,minMinutes=INCIDENT_MIN){
  const out=[]; let i=0;
  while(i<intervals.length){
    if(intervals[i].ok===false){
      let from=intervals[i].from, mins=0, j=i;
      while(j<intervals.length && intervals[j].ok===false){ mins+=intervals[j].mins; j++; }
      if(mins>=minMinutes) out.push({from,to:intervals[j-1].to,mins});
      i=j;
    } else i++;
  }
  return out;
}
function kpisFromIntervals(intervals){
  let on=0,off=0,unk=0;
  for(const it of intervals){ if(it.ok===true) on+=it.mins; else if(it.ok===false) off+=it.mins; else unk+=it.mins; }
  const total=on+off+unk||1;
  return {uptime:on/(on+off), downtimeMin:off, onlineSlots:Math.round(on/SLOT_MIN),
          offlineSlots:Math.round(off/SLOT_MIN), unknownSlots:Math.round(unk/SLOT_MIN), points:intervals.length};
}
/* Gruppen pro Kalendertag */
function daysFromIntervals(intervals){
  const map=new Map();
  for(const it of intervals){
    const d=new Date(it.from);
    const key = d.getFullYear()+'-'+(d.getMonth()+1)+'-'+d.getDate();
    const m=map.get(key)||{from:new Date(d.getFullYear(),d.getMonth(),d.getDate()).toISOString(),on:0,off:0,unk:0,total:0};
    if(it.ok===true) m.on+=it.mins; else if(it.ok===false) m.off+=it.mins; else m.unk+=it.mins;
    m.total+=it.mins; map.set(key,m);
  }
  return [...map.values()].sort((a,b)=>new Date(a.from)-new Date(b.from));
}
function classifyDay(d){ const total=d.total||1, offPct=d.off/total, unkPct=d.unk/total;
  if(offPct>=0.5) return 'r'; if(d.off>0 || unkPct>=0.2) return 'o'; return 'g'; }

/* Render */
function setCols(n){ barsEl.style.setProperty('--cols', Math.max(1,n)); }

/* 24h: echte Intervalle + echte Minuten im Tooltip */
let currentBarsData=[];
function render24h(intervals){
  clear(barsEl); barsEl.className='bars mode-24h'; setCols(intervals.length);
  currentBarsData = intervals;
  const frag=document.createDocumentFragment();
  intervals.forEach(it=>{
    const el=document.createElement('div'); el.className='bar '+statusClass(it.ok);
    const txt = it.mins<60 ? `${it.mins} Minuten` : fmtDur(it.mins);
    el.addEventListener('mouseenter',ev=>showTip(ev,txt,it.ok,it.from,'History'));
    el.addEventListener('mousemove',ev=>showTip(ev,txt,it.ok,it.from,'History'));
    el.addEventListener('mouseleave',()=>{el.classList.remove('focus'); hideTip();});
    el.addEventListener('touchstart',ev=>{el.classList.add('focus'); showTip(ev.touches[0],txt,it.ok,it.from,'History');},{passive:true});
    frag.appendChild(el);
  });
  barsEl.appendChild(frag);
}

/* 7d/30d: exakt N Kalendertage */
function renderDays(days,daysWanted){
  const lastN = days.slice(-daysWanted); // exakt 7 bzw. 30
  clear(barsEl); barsEl.className='bars'; setCols(lastN.length);
  currentBarsData = lastN.map(d=>({from:d.from, ok: classifyDay(d)==='r'?false:(classifyDay(d)==='g'?true:null)}));
  const frag=document.createDocumentFragment();
  lastN.forEach(d=>{
    const el=document.createElement('div'); el.className='bar '+(classifyDay(d)==='o'?'o':classifyDay(d));
    const on=(d.on/d.total)*100, off=(d.off/d.total)*100, unk=(d.unk/d.total)*100;
    const state = classifyDay(d)==='r'?false:(classifyDay(d)==='g'?true:null);
    const txt=`on ${on.toFixed(1)}% • off ${off.toFixed(1)}% • unknown ${unk.toFixed(1)}%`;
    el.addEventListener('mouseenter',ev=>showTip(ev,'1 Tag',state,d.from,txt));
    el.addEventListener('mousemove',ev=>showTip(ev,'1 Tag',state,d.from,txt));
    el.addEventListener('mouseleave',()=>{el.classList.remove('focus'); hideTip();});
    el.addEventListener('touchstart',ev=>{el.classList.add('focus'); showTip(ev.touches[0],'1 Tag',state,d.from,txt);},{passive:true});
    frag.appendChild(el);
  });
  barsEl.appendChild(frag);
}

/* Desktop Hoverline */
if(!isTouch){
  barsEl.addEventListener('mousemove',e=>{
    const rect=barsEl.getBoundingClientRect();
    const x=clamp(e.clientX-rect.left,0,rect.width);
    const cols=parseInt(getComputedStyle(barsEl).getPropertyValue('--cols'))||1;
    const gap=parseFloat(getComputedStyle(barsEl).gap)||0;
    const cellW=(rect.width - gap*(cols-1))/cols;
    const idx=Math.round(x / (cellW+gap));
    const snapped = clamp(idx*(cellW+gap), 0, rect.width);
    hoverLine.style.left=snapped+'px';
    hoverLine.style.display='block';
  });
  barsEl.addEventListener('mouseleave',()=>{hoverLine.style.display='none'; hideTip();});
}else{
  hoverLine.style.display='none';
  /* Mobile: Container-Touch → nächster Balken */
  const touchToIndex = (clientX)=>{
    const rect=barsEl.getBoundingClientRect();
    const cols=parseInt(getComputedStyle(barsEl).getPropertyValue('--cols'))||1;
    const gap=parseFloat(getComputedStyle(barsEl).gap)||0;
    const cellW=(rect.width - gap*(cols-1))/cols;
    const x=clamp(clientX-rect.left,0,rect.width-1);
    return Math.round(x / (cellW+gap));
  };
  const showByIndex = (idx)=>{
    const bars=[...barsEl.children];
    bars.forEach(b=>b.classList.remove('focus'));
    const el=bars[idx]; if(!el) return;
    el.classList.add('focus');
    const d=currentBarsData[idx];
    if(!d) return;
    const isDay = (legendInterval.textContent.includes('1 Tag'));
    const txt = isDay ? '1 Tag' : (d.mins? (d.mins<60? `${d.mins} Minuten` : fmtDur(d.mins)) : 'Probe');
    showTip({clientX:el.getBoundingClientRect().left+el.offsetWidth/2, clientY:barsEl.getBoundingClientRect().top}, txt, d.ok, d.from, isDay?'History':'History');
  };
  barsEl.addEventListener('touchstart',e=>{const i=touchToIndex(e.touches[0].clientX); showByIndex(i);},{passive:true});
  barsEl.addEventListener('touchmove' ,e=>{const i=touchToIndex(e.touches[0].clientX); showByIndex(i);},{passive:true});
}

/* Tooltip */
function showTip(e,range,ok,ts,src){
  TIP_ST.textContent=statusText(ok);
  TIP_TS.textContent=(range==='1 Tag')?localDate(ts):localTime(ts);
  TIP_SRC.textContent=src||''; TIP_RANGE.textContent=range;
  TIP.style.display='block';
  TIP.style.left=clamp(e.clientX,100,window.innerWidth-100)+'px';
  TIP.style.top =clamp(e.clientY,80,window.innerHeight-40)+'px';
}
function hideTip(){ TIP.style.display='none'; }

/* Heatmap */
function renderHeatmap(days){
  clear(heatEl);
  const last90 = days.slice(-90);
  last90.forEach(d=>{
    const c=document.createElement('div');
    c.className='cell '+(classifyDay(d));
    c.title=`${localDate(d.from)} – on ${((d.on/d.total)*100).toFixed(1)}%, off ${((d.off/d.total)*100).toFixed(1)}%`;
    heatEl.appendChild(c);
  });
  const label=document.createElement('div'); label.className='label';
  if(last90.length){
    label.textContent=`Zeitraum: ${localDate(last90[0].from)} – ${localDate(last90[last90.length-1].from)}`;
  }else{ label.textContent='Keine Daten'; }
  heatEl.appendChild(label);
}

/* Latency */
async function loadLatencySeries(){ try{ const d = await fetchJSON(API_LATENCY); return Array.isArray(d)? d : []; } catch{ return []; } }
function renderLatencyBadge(lat){ const txt = (lat?.p50_ms!=null && lat?.p95_ms!=null) ? `${lat.p50_ms} / ${lat.p95_ms} ms` : '–'; latVal.textContent = txt; }
function renderSparkline(series){
  latSpark.innerHTML='';
  if(!series.length) return;
  const last = series.slice(-50);
  const max = Math.max(100, ...last.map(x=>x.p95_ms||0));
  last.forEach(x=>{
    const h = Math.round(Math.min(1,(x.p95_ms||0)/max) * 26) + 2;
    const d = document.createElement('div');
    d.className='s ' + ((x.p95_ms||0)>=P95_BAD ? 'bad' : ( (x.p95_ms||0)>=P95_WARN ? 'warn':'ok'));
    d.style.height = `${h}px`;
    latSpark.appendChild(d);
  });
}
function isDegraded(series){
  if(!series.length) return false;
  const cut = Date.now() - DEGRADE_WINDOW_MIN*60*1000;
  const inWin = series.filter(x=> new Date(x.ts).getTime() >= cut);
  if(inWin.some(x=> (x.p95_ms||0) >= P95_BAD)) return true;
  let streak=0;
  for(const x of series.slice(-10)){
    if((x.p95_ms||0) >= P95_WARN){ streak++; if(streak>=3) return true; }
    else streak=0;
  }
  return false;
}

/* externe Incident-Gründe */
async function loadExternalIncidentReasons(){ try{ return await fetchJSON(API_INCIDENTS); } catch { return []; } }
function overlap(aFrom,aTo,bFrom,bTo){ return (new Date(aFrom)<=new Date(bTo)) && (new Date(bFrom)<=new Date(aTo)); }
async function renderIncidents(intervals){
  const incidents=computeIncidents(intervals);
  const reasons=await loadExternalIncidentReasons();
  if(!incidents.length){ incWrap.innerHTML=''; return; }
  const ul=document.createElement('ul');
  incidents.forEach(ev=>{
    const match=reasons.find(r=>overlap(ev.from,ev.to,r.from,r.to));
    const li=document.createElement('li');
    li.textContent=`Ausfall ${localTime(ev.from)} – ${localTime(ev.to)} (${fmtDur(Math.round(ev.mins))})`+(match?` – Grund: ${match.reason}`:'');
    ul.appendChild(li);
  });
  incWrap.innerHTML='<h3>Incidents</h3>'; incWrap.appendChild(ul);
}

/* Range & Timer */
function onRangeChange(v){
  const is24 = v==='24h';
  barsEl.classList.toggle('mode-24h',is24);
  $('foot-left').textContent = is24?'24 hours':(v==='7d'?'7 days':'30 days');
  $('foot-right').textContent='Today';
  legendInterval.textContent = is24 ? '1 Balken = 1 Probe (variable Minuten)' : '1 Balken = 1 Tag';
  load(v);
}
let timer=null;
function startTimer(){ stopTimer(); timer=setInterval(()=>{const v=rangeCtl.querySelector('input:checked')?.value||'24h'; load(v);},60_000); }
function stopTimer(){ if(timer){clearInterval(timer); timer=null;} }
autoCtl.addEventListener('change', e=> e.target.checked?startTimer():stopTimer());
rangeCtl.addEventListener('change', e=> onRangeChange(e.target.value));

/* Main Load */
async function load(range){
  try{ const live=await fetchJSON(API_LIVE+'?t='+Date.now()); setLive(live.ok,live.generated); }catch{ setLive(null,null); }

  let data;
  try{ data=await loadHistory(range); }
  catch{ metaSrc.textContent='Quelle: History (Fehler)'; uptimeEl.textContent='–'; dtimeEl.textContent='–';
         kOnline.textContent='0'; kOffline.textContent='0'; kUnknown.textContent='0'; kPoints.textContent='0';
         incWrap.innerHTML='<h3>Incidents</h3><ul><li>History nicht erreichbar</li></ul>'; return; }

  const hist=Array.isArray(data.history)?data.history:[]; const generated=data.generated||new Date().toISOString();
  const svc=data.service||{}; $('svc-name').textContent=svc.name||'Minecraft Bedrock'; $('svc-host').textContent=[svc.host,svc.port].filter(Boolean).join(':');
  const stale=(Date.now()-new Date(generated).getTime())/60000 > STALE_MIN; staleEl.hidden=!stale;

  const intervals=toIntervals(hist,generated);

  if(range==='24h'){
    const since=Date.now()-DAY_MS;
    const lastPts=intervals.filter(i=>new Date(i.from).getTime()>=since);
    render24h(lastPts);
    const k=kpisFromIntervals(lastPts);
    uptimeEl.textContent=fmtPct(k.uptime); dtimeEl.textContent=fmtDur(Math.round(k.downtimeMin));
    kOnline.textContent=k.onlineSlots; kOffline.textContent=k.offlineSlots; kUnknown.textContent=k.unknownSlots; kPoints.textContent=k.points;
    await renderIncidents(lastPts);
  }else{
    const span=range==='7d'?7*DAY_MS:30*DAY_MS;
    const since=Date.now()-span;
    const inSpan=intervals.filter(i=>new Date(i.from).getTime()>=since);
    const days=daysFromIntervals(inSpan);
    renderDays(days, range==='7d'?7:30);  // exakt 7/30
    const k=kpisFromIntervals(inSpan);
    uptimeEl.textContent=fmtPct(k.uptime); dtimeEl.textContent=fmtDur(Math.round(k.downtimeMin));
    kOnline.textContent=k.onlineSlots; kOffline.textContent=k.offlineSlots; kUnknown.textContent=k.unknownSlots; kPoints.textContent=k.points;
    incWrap.innerHTML='';
  }

  renderHeatmap(daysFromIntervals(intervals));
  metaSrc.textContent='Quelle: History ✓';

  // Latency
  const latSeries = await loadLatencySeries();
  const latestLat = latSeries[latSeries.length-1];
  renderLatencyBadge(latestLat);
  renderSparkline(latSeries);
  const degraded = (()=>{
    if(!latSeries.length) return false;
    const cut = Date.now() - DEGRADE_WINDOW_MIN*60*1000;
    const inWin = latSeries.filter(x=> new Date(x.ts).getTime() >= cut);
    if(inWin.some(x=> (x.p95_ms||0) >= P95_BAD)) return true;
    let streak=0;
    for(const x of latSeries.slice(-10)){
      if((x.p95_ms||0) >= P95_WARN){ streak++; if(streak>=3) return true; } else streak=0;
    }
    return false;
  })();
  if(degraded && range==='24h'){
    const bars = Array.from(document.querySelectorAll('#bars .bar'));
    for(let i=1;i<=Math.min(3,bars.length);i++){ const el=bars[bars.length-i]; if(el){ el.classList.remove('g','r','u'); el.classList.add('o'); } }
    latBadge.classList.add('badge-warn');
  } else {
    latBadge.classList.remove('badge-warn');
  }
}

/* Init */
onRangeChange('24h'); startTimer();
</script>
</body>
</html>
