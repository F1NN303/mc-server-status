name: Notify Discord on status change

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

permissions:
  contents: write

concurrency:
  group: bedrock-status
  cancel-in-progress: true

env:
  API_URL: https://mc-server-status-black.vercel.app/api/bedrock
  STATUS_DIR: .status

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: true

      - name: Install jq & curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Ensure cache dir
        run: mkdir -p "$STATUS_DIR"

      - name: Fetch live status
        id: fetch
        shell: bash
        run: |
          set -euo pipefail

          if ! curl -fsSL "$API_URL" -o "$STATUS_DIR/live_raw.json"; then
            echo '{}' > "$STATUS_DIR/live_raw.json"
          fi

          if ! jq -e . "$STATUS_DIR/live_raw.json" >/dev/null 2>&1; then
            echo '{}' > "$STATUS_DIR/live_raw.json"
          fi

          jq -r '
            def parse_timestamp:
              if type == "string" then
                try fromdateiso8601 catch now
              elif type == "number" then
                .
              else
                now
              end;

            . as $root |
            ($root.lastChanged // $root.updatedAt // $root.timestamp // now) | parse_timestamp as $ts |
            {
              online: ($root.online // false),
              version: ($root.version // $root.bedrockVersion // "unknown"),
              motd: ($root.motd // $root.serverName // ""),
              players: {
                online: ($root.players.online // $root.playersOnline // 0),
                max: ($root.players.max // $root.playersMax // 0),
                sample: ($root.players.sample // [])
              },
              checked_at_unix: ($ts | floor),
              checked_at_iso: ($ts | strftime("%Y-%m-%d %H:%M:%S UTC"))
            }
          ' "$STATUS_DIR/live_raw.json" > "$STATUS_DIR/live.json"

          # Immer Update senden (auch ohne Ã„nderung)
          echo "changed=1" >> "$GITHUB_OUTPUT"

      - name: Load previous status
        run: test -f "$STATUS_DIR/prev.json" || echo '{}' > "$STATUS_DIR/prev.json"

      - name: Update or Create Discord message
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${WEBHOOK_URL:-}" ]; then
            echo "ERROR: DISCORD_WEBHOOK_URL Secret nicht gesetzt!"
            exit 1
          fi

          ONLINE=$(jq -r '.online' "$STATUS_DIR/live.json")
          PLAYERS_ONLINE=$(jq -r '.players.online' "$STATUS_DIR/live.json")
          PLAYERS_MAX=$(jq -r '.players.max' "$STATUS_DIR/live.json")
          VERSION=$(jq -r '.version' "$STATUS_DIR/live.json")
          MOTD=$(jq -r '.motd' "$STATUS_DIR/live.json")
          CHECKED=$(jq -r '.checked_at_iso' "$STATUS_DIR/live.json")
          PREV_ONLINE=$(jq -r '.online // "unknown"' "$STATUS_DIR/prev.json")

          # Status-spezifische Variablen
          if [ "$ONLINE" = "true" ]; then
            COLOR=3066993
            EMOJI="ðŸŸ¢"
            STATUS_TEXT="ONLINE"
            PING_CONTENT=""
            if [ "$PREV_ONLINE" = "false" ]; then
              TITLE="âœ… Server ist wieder ONLINE!"
              PING_CONTENT="@everyone"
            else
              TITLE="Server Status"
            fi
          else
            COLOR=15158332
            EMOJI="ðŸ”´"
            STATUS_TEXT="OFFLINE"
            PING_CONTENT=""
            if [ "$PREV_ONLINE" = "true" ]; then
              TITLE="âš ï¸ Server ist OFFLINE!"
              PING_CONTENT="@everyone"
            else
              TITLE="Server Status"
            fi
          fi

          # Player-Liste
          PLAYER_SAMPLE=$(jq -r '
            if .players.sample | length > 0 then
              .players.sample | map("â€¢ " + .) | join("\n")
            else
              "_Keine Spieler online_"
            end
          ' "$STATUS_DIR/live.json")

          # Uptime berechnen (letzte 24h)
          if [ -f "public/history.json" ]; then
            UPTIME_24H=$(jq -r '
              [.history[] | select((.ts | fromdateiso8601) > (now - 86400))] as $last24h |
              if ($last24h | length) > 0 then
                ([$last24h[] | select(.ok == true)] | length) / ($last24h | length) * 100 | floor
              else
                0
              end
            ' public/history.json 2>/dev/null || echo "0")
          else
            UPTIME_24H="N/A"
          fi

          # Payload erstellen
          jq -n \
            --arg content "$PING_CONTENT" \
            --arg title "$TITLE" \
            --arg status "$STATUS_TEXT" \
            --arg emoji "$EMOJI" \
            --arg players_online "$PLAYERS_ONLINE" \
            --arg players_max "$PLAYERS_MAX" \
            --arg version "$VERSION" \
            --arg motd "$MOTD" \
            --arg player_sample "$PLAYER_SAMPLE" \
            --arg checked "$CHECKED" \
            --arg uptime "$UPTIME_24H" \
            --argjson color "$COLOR" '
            {
              content: (if $content != "" then $content else null end),
              embeds: [{
                title: $title,
                description: ($emoji + " **" + $status + "**\n" + $motd),
                color: $color,
                fields: [
                  {name: "ðŸ‘¥ Spieler", value: ($players_online + " / " + $players_max), inline: true},
                  {name: "ðŸ“¦ Version", value: $version, inline: true},
                  {name: "ðŸ“Š Uptime 24h", value: ($uptime + "%"), inline: true},
                  {name: "ðŸ‘¤ Online Spieler", value: $player_sample, inline: false},
                  {name: "ðŸ• Letzter Check", value: $checked, inline: false}
                ],
                timestamp: (now | todate),
                footer: {text: "Auto-Update alle 5 Min"}
              }]
            }
          ' > payload.json

          # Message ID aus vorherigem Run laden
          MESSAGE_ID=""
          if [ -f "$STATUS_DIR/message_id.txt" ]; then
            MESSAGE_ID=$(cat "$STATUS_DIR/message_id.txt")
          fi

          if [ -n "$MESSAGE_ID" ]; then
            # UPDATE existierende Nachricht
            echo "Updating existing message ID: $MESSAGE_ID"
            
            # Extrahiere Webhook-Token aus URL
            WEBHOOK_ID=$(echo "$WEBHOOK_URL" | grep -oP 'webhooks/\K[0-9]+')
            WEBHOOK_TOKEN=$(echo "$WEBHOOK_URL" | grep -oP 'webhooks/[0-9]+/\K[^/?]+')
            
            HTTP_CODE=$(curl -w "%{http_code}" -o response.txt -s \
              -X PATCH \
              -H "Content-Type: application/json" \
              -d @payload.json \
              "https://discord.com/api/v10/webhooks/${WEBHOOK_ID}/${WEBHOOK_TOKEN}/messages/${MESSAGE_ID}")

            echo "Update Response: $HTTP_CODE"
            cat response.txt || true

            if [ "$HTTP_CODE" = "200" ]; then
              echo "Message updated successfully!"
            else
              echo "Update failed, creating new message..."
              MESSAGE_ID=""
            fi
          fi

          # Wenn keine Message ID oder Update fehlgeschlagen: Neue Nachricht senden
          if [ -z "$MESSAGE_ID" ]; then
            echo "Creating new Discord message..."
            
            HTTP_CODE=$(curl -w "%{http_code}" -o response.txt -s \
              -H "Content-Type: application/json" \
              -d @payload.json \
              "${WEBHOOK_URL}?wait=true")

            echo "Create Response: $HTTP_CODE"
            
            if [ "$HTTP_CODE" = "200" ]; then
              # Speichere Message ID fÃ¼r zukÃ¼nftige Updates
              NEW_MESSAGE_ID=$(jq -r '.id' response.txt)
              echo "$NEW_MESSAGE_ID" > "$STATUS_DIR/message_id.txt"
              echo "New message created with ID: $NEW_MESSAGE_ID"
            else
              echo "Failed to create message"
              cat response.txt || true
              exit 1
            fi
          fi

      - name: Update cache
        shell: bash
        run: |
          set -euo pipefail
          cp "$STATUS_DIR/live.json" "$STATUS_DIR/prev.json"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$STATUS_DIR/prev.json" "$STATUS_DIR/message_id.txt"
          git commit -m "chore(status): update bedrock status [skip ci]" || exit 0
          git push
